<template>
  <div
    v-if="textStore.text"
    class="mt-2"
  >
    <annotate-text
      :store-id="storeId"
      :snapper="useWordSnapper"
      @adjust-selection="adjustSelection"
      @select-annotation="selectAnnotation"
      @save-annotation="saveAnnotation"
      @close-annotation="closeAnnotation"
      @delete-annotation="deleteAnnotation"
      @change-select-filter="annotationStore.changeSelectionFilter"
    />
  </div>
  <div
    v-if="modeToast"
    class="toast toast-center z-[3000]"
  >
    <div
      role="alert"
      class="alert border-primary bg-white"
    >
      <span>{{ modeToast.text }}</span>
      <div class="flex gap-2">
        <Btn
          v-if="modeToast.deny"
          :color="Color.secondary"
          @click="modeToast.deny"
        >
          Close
        </Btn>
        <Btn
          v-if="modeToast.save"
          @click="modeToast.save"
        >
          Save
        </Btn>
      </div>
    </div>
  </div>
</template>
<script setup lang="ts">
import { computed, effect, onMounted } from 'vue';

import type { W3CAnnotation } from '@ghentcdh/annotations/core';
import { useWordSnapper } from '@ghentcdh/annotations/vue';
import { Btn, Color } from '@ghentcdh/ui';

import AnnotateText from './controls/annotate-text/annotate-text.vue';
import type { MODES } from './controls/annotate-text/props';
import { useAnnotationStore } from './controls/annotate-text/store/annotation.store';
import { useModeStore } from './controls/annotate-text/store/mode.store';
import { useTextStore } from './text.store';
import { useBookMenuStore } from '../book-menu.store';

const textStore = useTextStore();
// Create a new store each time we have a new text
const storeId = `identify_and_translate_${Date.now()}`;

const annotationStore = useAnnotationStore(storeId);
const modeStore = useModeStore();
const bookMenuStore = useBookMenuStore();

effect(() => {
  const sources = textStore.sources;
  const elementsMenu = [
    {
      label: 'Elements',
      items: [
        sources.map((s) => ({
          label: `Generate blocks ${s.text_type}`,
          action: () => generateBlocks(s.id),
        })),
        {
          label: 'Create annotation',
          action: () => createAnnotation(),
        },
        {
          label: 'Create example',
          action: () => createAnnotation('create-example'),
        },
      ].flat(),
    },
  ];

  bookMenuStore.setExtraMenu(elementsMenu);
});

effect(() => {
  const activeMode = modeStore.activeMode;

  bookMenuStore.setBreadcrumbs(
    [
      {
        label: 'Annotate',
      },
    ]
      .filter((m) => !!m)
      .concat(),
  );
});

const modeToasts: Record<
  MODES,
  { deny?: () => void; save?: () => void; text: string }
> = {
  'create-annotation': {
    deny: () => modeStore.resetMode(),
    text: 'Create new annotation by selecting text',
  },
  'create-example': {
    deny: () => modeStore.resetMode(),
    text: 'Create new example annotation by selecting text',
  },
  generate: {
    save: () => saveGeneratedBlocks(),
    deny: () => cancelGeneratedBlocks(),
    text: 'The autogenerated blocks are not saved',
  },
  edit: {
    deny: () => {
      closeAnnotation();
    },
    text: 'Current annotation is edited and not saved',
  },
  translate: {
    deny: () => modeStore.resetMode(),
    text: 'Select an annotation for translation',
  },
  link_buckets: {
    deny: () => modeStore.resetMode(),
    text: 'Select an annotation to link',
  },
  adjust_annotation: {
    deny: () => {
      annotationStore.changeSelectionFilter({});
      modeStore.changeMode('edit');
    },

    text: 'Adjust the selected annotation',
  },
};

const modeToast = computed(() =>
  modeStore.activeMode ? modeToasts[modeStore.activeMode] : null,
);

effect(() => {
  if (!textStore.text) return;
  annotationStore.init(textStore.sources, textStore.textId);
});

const generateBlocks = (sourceId: string) => {
  modeStore.changeMode('generate', () => {
    annotationStore.autoGenerateBlocks(sourceId);
  });
};

const saveGeneratedBlocks = () => {
  annotationStore.selectAnnotation(null);
  annotationStore.saveGeneratedBlocks();
  modeStore.resetMode();
};

const cancelGeneratedBlocks = () => {
  closeAnnotation();
};

const createAnnotation = (mode: MODES = 'create-annotation') => {
  modeStore.changeMode(mode, () => {
    annotationStore.selectAnnotation(null);
    // cancelGeneratedBlocks();
  });
};

const saveAnnotation = (id: string | null, annotation: W3CAnnotation) => {
  annotationStore.saveOrCreateAnnotation(id, annotation);
};

const adjustSelection = (id: string | null) => {
  modeStore.changeMode('adjust_annotation');
  annotationStore.changeSelectionFilter({
    annotationId: id,
  });
};

const selectAnnotation = (
  annotationId: string | null,
  textContentUri: string,
) => {
  annotationStore.selectAnnotation({ annotationId, textContentUri });
};

const deleteAnnotation = (annotation: W3CAnnotation) => {
  annotationStore.deleteAnnotation(annotation.id);
};

onMounted(() => {
  modeStore.registerOnResetFn(() => {
    annotationStore.selectAnnotation(null);
    annotationStore.changeSelectionFilter({});
    annotationStore.cancelNewAnnotations();
  });
});

const closeAnnotation = () => {
  annotationStore.selectAnnotation(null);
  annotationStore.changeSelectionFilter({});
  annotationStore.cancelNewAnnotations();
  modeStore.resetMode();
};
</script>
