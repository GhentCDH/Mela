<template>
  <template v-if="textStore.text">
    <annotate-text
      :store-id="storeId"
      @close-annotation="closeAnnotation"
    />
  </template>
  <div
    v-if="modeToast"
    class="toast toast-center z-[3000]"
  >
    <div
      role="alert"
      class="alert border-primary bg-white"
    >
      <span>{{ modeToast.text }}</span>
      <div class="flex gap-2">
        <Btn
          v-if="modeToast.deny"
          :color="Color.secondary"
          @click="modeToast.deny"
        >
          Close
        </Btn>
        <Btn
          v-if="modeToast.save"
          @click="modeToast.save"
        >
          Save
        </Btn>
      </div>
    </div>
  </div>
</template>
<script setup lang="ts">
import { computed, effect, onMounted } from 'vue';

import type { SourceModel } from '@ghentcdh/annotations/core';
import { Btn, Color } from '@ghentcdh/ui';

import AnnotateText from './controls/annotate-text/annotate-text.vue';
import type { MODES } from './controls/annotate-text/props';
import { useAnnotationStore } from './controls/annotate-text/store/annotation.store';
import { useModeStore } from './controls/annotate-text/store/mode.store';
import { useTextStore } from './text.store';
import { useBookMenuStore } from '../book-menu.store';
import { useActiveAnnotationStore } from './controls/annotate-text/store/active-annotation.store';
import { ModalSelectionService } from './controls/annotate-text/view/selection/modal-selection.service';

const textStore = useTextStore();
// Create a new store each time we have a new text
const storeId = `identify_and_translate_${Date.now()}`;

const annotationStore = useAnnotationStore(storeId);
const activeAnnotationStore = useActiveAnnotationStore(storeId);
const modeStore = useModeStore();
const bookMenuStore = useBookMenuStore();

effect(() => {
  const sources = annotationStore.sources;
  const elementsMenu = [
    {
      label: 'Elements',
      items: [
        sources.map((s) => ({
          label: `Generate blocks ${s.content.label}`,
          action: () => generateBlocks(s.id),
        })),
        sources.map((s) => ({
          label: `Create Paragraph for ${s.content.label}`,
          action: () => createAnnotationParagraph(s),
        })),
      ].flat(),
    },
  ];

  bookMenuStore.setExtraMenu(elementsMenu);
});

effect(() => {
  const activeMode = modeStore.activeMode;

  bookMenuStore.setBreadcrumbs(
    [
      {
        label: 'Annotate',
      },
    ]
      .filter((m) => !!m)
      .concat(),
  );
});

const modeToasts: Record<
  MODES,
  { deny?: () => void; save?: () => void; text: string }
> = {
  'create-annotation': {
    deny: () => modeStore.resetMode(),
    text: 'Create new annotation by selecting text',
  },
  'create-example': {
    deny: () => modeStore.resetMode(),
    text: 'Create new example annotation by selecting text',
  },
  generate: {
    save: () => saveGeneratedBlocks(),
    deny: () => cancelGeneratedBlocks(),
    text: 'The autogenerated blocks are not saved',
  },
  edit: {
    deny: () => {
      closeAnnotation();
    },
    text: 'Current annotation is edited and not saved',
  },
  translate: {
    deny: () => modeStore.resetMode(),
    text: 'Select an annotation for translation',
  },
  link_buckets: {
    deny: () => modeStore.resetMode(),
    text: 'Select an annotation to link',
  },
  adjust_annotation: {
    deny: () => {
      annotationStore.changeSelectionFilter({});
      modeStore.changeMode('edit');
    },

    text: 'Adjust the selected annotation',
  },
};

const modeToast = computed(() =>
  modeStore.activeMode ? modeToasts[modeStore.activeMode] : null,
);

effect(() => {
  if (!textStore.text) return;
  annotationStore.init(textStore.sources, textStore.textId);
});

const generateBlocks = (sourceId: string) => {
  modeStore.changeMode('generate', () => {
    annotationStore.autoGenerateBlocks(sourceId);
  });
};

const saveGeneratedBlocks = () => {
  activeAnnotationStore.selectAnnotation(null);
  annotationStore.saveGeneratedBlocks();
  modeStore.resetMode();
};

const cancelGeneratedBlocks = () => {
  closeAnnotation();
};

const createAnnotation = (mode: MODES = 'create-annotation') => {
  modeStore.changeMode(mode, () => {
    activeAnnotationStore.selectAnnotation(null);
    // cancelGeneratedBlocks();
  });
};

onMounted(() => {
  modeStore.registerOnResetFn(() => {
    activeAnnotationStore.selectAnnotation(null);
    annotationStore.changeSelectionFilter({});
    annotationStore.cancelNewAnnotations();
  });
  closeAnnotation();
});

const closeAnnotation = () => {
  activeAnnotationStore.selectAnnotation(null);
  annotationStore.changeSelectionFilter({});
  annotationStore.cancelNewAnnotations();
  modeStore.resetMode();
};

const createAnnotationParagraph = (source: SourceModel) => {
  ModalSelectionService.createSelection({
    source: source,
    annotationType: 'paragraph',
    storeId: storeId,
    onClose: (result) => {
      if (result?.valid) {
        const annotation = result.data;
        activeAnnotationStore.selectAnnotation({
          textContentUri: source.uri,
          annotationId: annotation.id,
        });
      }
    },
  });
};
</script>
