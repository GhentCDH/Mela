<template>
  <Menu
    title="Elements"
    :menu="menuElements"
    :breadcrumbs="breadcrumbs"
  />

  <div
    v-if="textStore.text"
    class="mt-2"
  >
    <annotate-text
      :store-id="storeId"
      :snapper="useWordSnapper"
      @save-annotation="saveAnnotation"
      @close-annotation="closeAnnotation"
      @delete-annotation="deleteAnnotation"
      @change-select-filter="annotationStore.changeSelectionFilter"
    />
  </div>
  <div
    v-if="modeToast"
    class="toast toast-center"
  >
    <div
      role="alert"
      class="alert alert-success bg-white"
    >
      <span>{{ modeToast.text }}</span>
      <div class="flex gap-2">
        <Btn
          v-if="modeToast.deny"
          :color="Color.secondary"
          @click="modeToast.deny"
        >
          Close
        </Btn>
        <Btn
          v-if="modeToast.save"
          @click="modeToast.save"
        >
          Save
        </Btn>
      </div>
    </div>
  </div>
</template>
<script setup lang="ts">
import { computed, effect, onMounted } from 'vue';

import type { W3CAnnotation } from '@ghentcdh/annotations/core';
import { useWordSnapper } from '@ghentcdh/annotations/vue';
import { Btn, Color, Menu } from '@ghentcdh/ui';

import AnnotateText from './controls/annotate-text/annotate-text.vue';
import type { MODES } from './controls/annotate-text/props';
import { useAnnotationStore } from './controls/annotate-text/store/annotation.store';
import { useModeStore } from './controls/annotate-text/store/mode.store';
import { useTextStore } from './text.store';

const textStore = useTextStore();
// Create a new store each time we have a new text
const storeId = `identify_and_translate_${Date.now()}`;

const annotationStore = useAnnotationStore(storeId);
const modeStore = useModeStore();

const menuElements = computed(() => {
  return [
    {
      label: 'Elements',
      items: [
        textStore.sources.map((s) => ({
          label: `Generate blocks ${s.text_type}`,
          action: () => generateBlocks(s.id),
        })),
        {
          label: 'Create annotation',
          action: () => createAnnotation(),
        },
        {
          label: 'Create example',
          action: () => createAnnotation('create-example'),
        },
      ].flat(),
    },
  ];
});

const breadcrumbs = computed(() => {
  return textStore.text
    ? [
        {
          label: 'Texts',
          routerLink: 'text-index',
        },
        {
          label: `${textStore.text.name} (${textStore.text.author?.name})`,
        },
        modeStore.activeMode
          ? {
              label: modeStore.activeMode,
            }
          : null,
      ].filter((m) => !!m)
    : [];
});

const modeToasts: Record<
  MODES,
  { deny?: () => void; save?: () => void; text: string }
> = {
  'create-annotation': {
    deny: () => modeStore.resetMode(),
    text: 'Create new annotation by selecting text',
  },
  'create-example': {
    deny: () => modeStore.resetMode(),
    text: 'Create new example annotation by selecting text',
  },
  generate: {
    save: () => saveGeneratedBlocks(),
    deny: () => cancelGeneratedBlocks(),
    text: 'The autogenerated blocks are not saved',
  },
  edit: {
    deny: () => {
      closeAnnotation();
    },
    text: 'Current annotation is edited and not saved',
  },
  translate: {
    deny: () => modeStore.resetMode(),
    text: 'Select an annotation for translation',
  },
  link_buckets: {
    deny: () => modeStore.resetMode(),
    text: 'Select an annotation to link',
  },
};

const modeToast = computed(() =>
  modeStore.activeMode ? modeToasts[modeStore.activeMode] : null,
);

effect(() => {
  if (!textStore.text) return;
  annotationStore.init(textStore.sources, textStore.textId);
});

const generateBlocks = (sourceId: string) => {
  modeStore.changeMode('generate', () => {
    annotationStore.autoGenerateBlocks(sourceId);
  });
};

const saveGeneratedBlocks = () => {
  annotationStore.selectAnnotation(null);
  annotationStore.saveGeneratedBlocks();
  modeStore.resetMode();
};

const cancelGeneratedBlocks = () => {
  closeAnnotation();
};

const createAnnotation = (mode: MODES = 'create-annotation') => {
  modeStore.changeMode(mode, () => {
    annotationStore.selectAnnotation(null);
    // cancelGeneratedBlocks();
  });
};

const saveAnnotation = (id: string | null, annotation: W3CAnnotation) => {
  annotationStore.saveOrCreateAnnotation(id, annotation);
};

const deleteAnnotation = (annotation: W3CAnnotation) => {
  annotationStore.deleteAnnotation(annotation.id);
};

onMounted(() => {
  modeStore.registerOnResetFn(() => {
    annotationStore.selectAnnotation(null);
    annotationStore.changeSelectionFilter({});
    annotationStore.cancelNewAnnotations();
  });
});

const closeAnnotation = () => {
  annotationStore.selectAnnotation(null);
  annotationStore.changeSelectionFilter({});
  annotationStore.cancelNewAnnotations();
  modeStore.resetMode();
};
</script>
