version: "3.9"

services:

  backend:
    image: mela/backend
    container_name: mela.app.backend
    deploy:
      resources:
        limits:
          cpus: "2"
          memory: "2G"
    build:
      context: backend
      target: dev
      
    #before starting the backend, we need to make sure that the authentication service is up and running and healthy
    depends_on:
      authentication: 
          condition: service_healthy
    ports:
      - "127.0.0.1:${BACKEND_EXTERNAL_TCP_PORT}:${BACKEND_INTERNAL_TCP_PORT}"
    volumes:
      - ./backend:/app
      - ~/.docker/mounts/mela/bakend/homedir:/root
    environment:
      BACKEND_DB_CONNECTION_STRING: "postgresql+asyncpg://${DATABASE_APP_USER}:${DATABASE_APP_PASSWORD}@${DATABASE_APP_HOST}/${DATABASE_APP_DBNAME}"
      BACKEND_DB_TEST_CONNECTION_STRING: "postgresql+asyncpg://${DATABASE_TEST_USER}:${DATABASE_TEST_PASSWORD}@${DATABASE_TEST_HOST}/${DATABASE_TEST_DBNAME}"
      BACKEND_KEYCLOAK_ISSUER: $BACKEND_KEYCLOAK_ISSUER
      BACKEND_KEYCLOAK_CLIENT_ID: $BACKEND_KEYCLOAK_CLIENT_ID
      BACKEND_KEYCLOAK_REALM: $BACKEND_KEYCLOAK_REALM
      BACKEND_KEYCLOAK_CLIENT_SECRET: $BACKEND_KEYCLOAK_CLIENT_SECRET
    command: $BACKEND_COMMAND

  frontend:
    image: mela/frontend
    container_name: mela.app.frontend
    deploy:
      resources:
        limits:
          cpus: "2"
          memory: "2G"
    build:
      context: frontend
      target: dev
    ports:
      - "127.0.0.1:${FRONTEND_EXTERNAL_TCP_PORT}:${FRONTEND_INTERNAL_TCP_PORT}"
    tmpfs: /tmp # to avoid a problem with lingering tmp files related to server PID
    volumes:
      - ./frontend:/app
      - ~/.docker/mounts/mela/app/frontend/homedir:/root
    environment:
      FRONTEND_BACKEND_SCHEMA_URL: "http://backend:${BACKEND_INTERNAL_TCP_PORT}/schema/**" # For nuxt reverse proxy
      FRONTEND_BACKEND_API_URL: "http://backend:${BACKEND_INTERNAL_TCP_PORT}/api/**" # For nuxt reverse proxy
      AUTH_ORIGIN: $FRONTEND_AUTH_ORIGIN
      NUXT_AUTH_SECRET: $FRONTEND_NEXT_AUTH_SECRET
      FRONTEND_KEYCLOAK_CLIENT_ID: $BACKEND_KEYCLOAK_CLIENT_ID
      FRONTEND_KEYCLOAK_CLIENT_SECRET: $BACKEND_KEYCLOAK_CLIENT_SECRET
      FRONTEND_KEYCLOAK_ISSUER: $FRONTEND_KEYCLOAK_ISSUER
    command: $FRONTEND_COMMAND
  
  elasticsearch:
    image: elasticsearch:8.13.0
    container_name: mela.elasticsearch
    deploy:
      resources:
        limits:
          cpus: "1"
          memory: "1G"
    ports:
      - "127.0.0.1:9200:9200"
    environment:
      - ELASTIC_PASSWORD=elastic_password
      - discovery.type=single-node
      - xpack.security.enabled=false
      - xpack.security.http.ssl.enabled=false
      - xpack.security.transport.ssl.enabled=false
    volumes:
      -  ~/.docker/mounts/mela/elasticsearch:/usr/share/elasticsearch/data

  authentication:
    image: keycloak/keycloak:24.0.1
    container_name: mela.keycloak
    deploy:
      resources:
        limits:
          cpus: "2"
          memory: "2G"
    depends_on:
      database_auth: 
        condition: service_healthy
    ports:
      - "127.0.0.1:${KEYCLOAK_EXTERNAL_TCP_PORT}:${KEYCLOAK_INTERNAL_TCP_PORT}"
    healthcheck:
      # since keycloak does not have wget or curl, we need to use java to check the health, from here, thanks @sarath-soman https://gist.github.com/sarath-soman/5d9aec06953bbd0990c648605d4dba07
      test: ['CMD-SHELL', '[ -f /tmp/HealthCheck.java ] || echo "public class HealthCheck { public static void main(String[] args) throws java.lang.Throwable { System.exit(java.net.HttpURLConnection.HTTP_OK == ((java.net.HttpURLConnection)new java.net.URL(args[0]).openConnection()).getResponseCode() ? 0 : 1); } }" > /tmp/HealthCheck.java && java /tmp/HealthCheck.java http://localhost:8080/health/live']
      retries: 3
    environment:
      - KEYCLOAK_ADMIN=$KEYCLOAK_ADMIN_USERNAME
      - KEYCLOAK_ADMIN_PASSWORD=$KEYCLOAK_ADMIN_PASSWORD
      - KC_DB=postgres
      - KC_DB_URL=jdbc:postgresql://$DATABASE_AUTH_HOST/$DATABASE_AUTH_DBNAME
      - KC_DB_USERNAME=$DATABASE_AUTH_USERNAME
      - KC_DB_PASSWORD=$DATABASE_AUTH_PASSWORD
      - KC_HEALTH_ENABLED=true # enable health check at /health/live
    command: start-dev
  
  database_app:
    image: postgres:16.2-bookworm
    container_name: mela.data.app
    deploy:
      resources:
        limits:
          cpus: "1"
          memory: "256M"
    healthcheck:
      test:
        - CMD
        - pg_isready 
        - --dbname=$DATABASE_APP_DBNAME
        - --username=$DATABASE_APP_USERNAME
      retries: 5
    ports:
      - "127.0.0.1:${DATABASE_APP_EXTERNAL_TCP_PORT}:${DATABASE_APP_INTERNAL_TCP_PORT}"
    volumes:
      - ~/.docker/mounts/mela/data/app:/var/lib/postgresql/data
    environment:
      POSTGRES_USER: $DATABASE_APP_USER
      POSTGRES_PASSWORD: $DATABASE_APP_PASSWORD
      POSTGRES_DB: $DATABASE_APP_DBNAME

  database_test:
    image: postgres:16.2-bookworm
    container_name: mela.data.test
    deploy:
      resources:
        limits:
          cpus: "1"
          memory: "256M"
    healthcheck:
      test:
        - CMD
        - pg_isready 
        - --username=$DATABASE_TEST_USERNAME
        - --dbname=$DATABASE_TEST_DBNAME
      retries: 5
    volumes:
      - ~/.docker/mounts/mela/data/test:/var/lib/postgresql/data
    environment:
      POSTGRES_USER: $DATABASE_TEST_USERNAME
      POSTGRES_PASSWORD: $DATABASE_TEST_PASSWORD
      POSTGRES_DB: $DATABASE_TEST_DBNAME

  database_auth:
    image: postgres:16.2-bookworm
    container_name: mela.data.auth
    deploy:
      resources:
        limits:
          cpus: "1"
          memory: "256M"
    healthcheck:
      test:
        - CMD
        - pg_isready 
        - --username=$DATABASE_AUTH_USERNAME
        - --dbname=$DATABASE_AUTH_DBNAME
      retries: 5
    volumes:
      -  ~/.docker/mounts/mela/data/auth:/var/lib/postgresql/data
    environment:
      POSTGRES_USER: $DATABASE_AUTH_USERNAME
      POSTGRES_PASSWORD: $DATABASE_AUTH_PASSWORD
      POSTGRES_DB: $DATABASE_AUTH_DBNAME
